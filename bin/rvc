#!/usr/bin/env ruby
require 'readline'
require 'pp'
require 'trollop'
require 'rbvmomi'
require 'rbvmomi/trollop'
require 'shellwords'
require 'yaml'
require 'backports'
require 'rvc'

VIM = RbVmomi::VIM
include RVC::Util

Thread.abort_on_exception = true

MODULES = {}
CMD = Module.new

$opts = Trollop.options do
  banner <<-EOS
Ruby vSphere Console.

Usage:
       rvc [options] [username[:password]@]hostname[:path]

where [options] are:
EOS

  opt :insecure, "don't verify ssl certificate", :short => 'k', :default => (ENV['RBVMOMI_INSECURE'] == '1')
  opt :folder, "Initial directory", :short => 'F', :default => ENV['RVC_FOLDER'], :type => :string
  opt :cmd, "command to evaluate", :short => 'c', :multi => true, :type => :string
end

Trollop.die "1 argument expected" unless ARGV.length == 1

HOSTNAME_REGEX = %r{
  ^
  (?:
    ([^@:]+)
    (?::
     ([^@]*)
    )?
    @
  )?
  ([^@:]+)
  (?::(.*))?
  $
}x

match = HOSTNAME_REGEX.match ARGV[0]
Trollop.die "invalid hostname" unless match

username = match[1] || ENV['RBVMOMI_USER']
password = match[2] || ENV['RBVMOMI_PASSWORD']
host = match[3]
path = match[4]

$auth = {
  :host => host,
  :username => username,
  :password => password,
}

ALIASES = {
  'type' => 'basic.type',
  'debug' => 'basic.debug',
  'rc' => 'basic.rc',
  'reload' => 'basic.reload',
  'cd' => 'basic.cd',
  'ls' => 'basic.ls',
  'info' => 'basic.info',
  'i' => 'basic.info',
  'mv' => 'basic.mv',
  'destroy' => 'basic.destroy',
  'mark' => 'basic.mark',
  'm' => 'basic.mark',
  'help' => 'basic.help',
  'exit' => 'basic.quit',
  'quit' => 'basic.quit',
  'q' => 'basic.quit',

  'on' => 'vm.on',
  'off' => 'vm.off',
  'reset' => 'vm.reset',
  'r' => 'vm.reset',
  'suspend' => 'vm.suspend',
  's' => 'vm.suspend',
  'kill' => 'vm.kill',
  'k' => 'vm.kill',
  'ping' => 'vm.ping',
  'view' => 'vmrc.view',
  'v' => 'vmrc.view',
  'V' => 'vnc.view',
  'ssh' => 'vm.ssh'
}


## internal

def tokenize str
  Shellwords.shellwords(str)
end

def evalcmd str
  cmd, *args = tokenize str
  return unless cmd
  err "invalid command" unless cmd.is_a? String
  case cmd
  when RVC::Context::MARK_REGEX
    CMD.basic.cd cmd
  else
    if cmd.include? '.'
      module_name, cmd, = cmd.split '.'
    elsif ALIASES.member? cmd
      module_name, cmd, = ALIASES[cmd].split '.'
    else
      err "unknown alias #{cmd}"
    end

    m = MODULES[module_name] or err("unknown module #{module_name}")

    opts_block = m.opts_for(cmd.to_sym)
    parser = RVC::OptionParser.new cmd, &opts_block

    begin
      args, opts = parser.parse args
    rescue Trollop::HelpNeeded
      parser.educate
      return
    end

    if parser.has_options?
      m.send cmd.to_sym, *(args + [opts])
    else
      m.send cmd.to_sym, *args
    end
  end
end

def this
  $context.cur
end

def prompt_password
  system "stty -echo"
  $stdout.write "password: "
  $stdout.flush
  begin
    ($stdin.gets||exit(1)).chomp
  ensure
    system "stty echo"
    puts
  end
end

def prompt_insecure
  answer = Readline.readline "SSL certificate verification failed. Connect anyway? (y/n) "
  answer == 'yes' or answer == 'y'
end

## connect
loop do
  begin
    $vim = RbVmomi::VIM.new :host => host,
                            :port => 443,
                            :path => '/sdk',
                            :ns => 'urn:vim25',
                            :rev => '4.0',
                            :ssl => true,
                            :insecure => $opts[:insecure]
    break
  rescue OpenSSL::SSL::SSLError
    exit 1 unless prompt_insecure
    $opts[:insecure] = true
  rescue Errno::EHOSTUNREACH, SocketError
    abort $!.message
  end
end

# negotiate API version
rev = $vim.serviceContent.about.apiVersion
$vim.rev = [rev, '4.1'].min
$isVC = $vim.serviceContent.about.apiType == "VirtualCenter"

# authenticate
username = $isVC ? 'Administrator' : 'root' unless username
password_given = password != nil
loop do
  begin
    password = prompt_password unless password_given
    $vim.serviceContent.sessionManager.Login :userName => username,
                                             :password => password
    break
  rescue RbVmomi::VIM::InvalidLogin
    $stderr.puts $!.message
    exit 1 if password_given
  end
end

$context = RVC::Context.new $vim.rootFolder
$context.cd(path) if path

Readline.completion_proc = RVC::Completion::Completor
history_fn = "#{ENV['HOME']}/.rvc-history"
IO.foreach(history_fn) { |l| Readline::HISTORY << l.chomp } rescue puts "Welcome to RVC. Try the 'help' command."
history = File.open(history_fn, 'a')

RVC.reload_modules false
RVC.reload_rc

Thread.new do
  while true
    sleep 600
    $vim.serviceInstance.RetrieveServiceContent
  end
end

vim = $vim
$binding = binding
persist_ruby = false

def self.method_missing sym, *a
  str = sym.to_s
  if a.empty?
    if MODULES.member? str
      MODULES[str]
    elsif $context.marks.member?(str)
      $context.marks[str].obj
    elsif str[0..0] == '_' && $context.marks.member?(str[1..-1])
      $context.marks[str[1..-1]].obj
    else
      super
    end
  else
    super
  end
end

CMD.basic.ls '.'
loop do
begin
  input = $opts[:cmd].shift || Readline.readline("#{host}#{persist_ruby ? '~' : ":#{$context.display_path}>"} ", false) or break
  input = input.strip
  next if input.empty?
  if input == '//'
    persist_ruby = !persist_ruby
    next
  end

  (history.puts input; Readline::HISTORY << input) unless input == Readline::HISTORY.to_a[-1]

  if input[0..0] == '!'
    system_fg input[1..-1]
    next
  end

  ruby = persist_ruby
  if input =~ /^\//
    input = $'
    ruby = !ruby
  end

  if ruby
    result = eval(input, $binding)
    if input =~ /\#$/
      CMD.basic.type result.class.wsdl_name
    else
      pp result
    end
  else
    evalcmd input
  end
rescue SystemExit, IOError
  raise
rescue UserError, RuntimeError, RbVmomi::Fault
  if ruby
    puts "#{$!.class}: #{$!.message}"
    puts $!.backtrace * "\n"
  else
    case $!
    when RbVmomi::Fault, UserError
      puts $!.message
    else
      puts "#{$!.class}: #{$!.message}"
    end
  end
rescue Interrupt
  puts
rescue Exception
  puts "#{$!.class}: #{$!.message}"
  puts $!.backtrace * "\n"
end
end
